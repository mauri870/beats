// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

package main

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/logger"
)

// isHexString is a compiled regex to check for valid hex strings.
var isHexString = regexp.MustCompile(`^[0-9a-fA-F]+$`)

// downloadPage performs a GET request
func downloadPage(url string) (string, error) {
	client := &http.Client{}
	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return "", err
	}

	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	// Check for non-2xx status codes
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		resp.Body.Close() // Make sure to close the body on error
		return "", fmt.Errorf("bad status: %s", resp.Status)
	}

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(bodyBytes), nil
}

func writeCopyrightHeader(sb *strings.Builder) {
	sb.WriteString("// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n")
	sb.WriteString("// or more contributor license agreements. Licensed under the Elastic License;\n")
	sb.WriteString("// you may not use this file except in compliance with the Elastic License.\n\n")
	sb.WriteString("// Code generated by beats/x-pack/osquerybeat/ext/osquery-extension/pkg/jumplists/generate/main.go - DO NOT EDIT.\n\n")
	sb.WriteString("//go:build windows\n\n")
	sb.WriteString("package jumplists\n\n")
}

func loadSourceText(cachePath, sourceURL string, refresh bool, log *logger.Logger) (string, error) {
	if refresh {
		body, err := downloadPage(sourceURL)
		if err != nil {
			return "", err
		}
		if err := os.MkdirAll(filepath.Dir(cachePath), 0o755); err != nil {
			return "", fmt.Errorf("failed to create source cache directory: %w", err)
		}
		if err := os.WriteFile(cachePath, []byte(body), 0o644); err != nil {
			return "", fmt.Errorf("failed to write source cache %s: %w", cachePath, err)
		}
		log.Infof("updated local source cache: %s", cachePath)
		return body, nil
	}

	body, err := os.ReadFile(cachePath)
	if err != nil {
		return "", fmt.Errorf("failed to read source cache %s: %w (run generator with -refresh-sources to download)", cachePath, err)
	}
	return string(body), nil
}
